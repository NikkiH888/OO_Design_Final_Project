# Java
Java stores objects in the a heap which is divided into two areas. First, the nursery is used for new objects, but when it becomes too full some of the objects are moved to the second space which is the old space. After that the garbage collection will begin happening there after the old space full. The garbage collection is used when areas become full. Java does not support automatic reference counting.

# C#
When the object is created, memory is allocated for it, the constructor is run, and the object is considered live. If the object, or any part of it, cannot be accessed by any possible continuation of execution, other than the running of destructors, the object is considered no longer in use, and it becomes eligible for destruction. The C# compiler and the garbage collector may choose to analyze code to determine which references to an object may be used in the future. For instance, if a local variable that is in scope is the only existing reference to an object, but that local variable is never referred to in any possible continuation of execution from the current execution point in the procedure, the garbage collector may (but is not required to) treat the object as no longer in use. Once the object is eligible for destruction, at some unspecified later time the destructor for the object is run. Once the destructor for an object is run, if that object, or any part of it, cannot be accessed by any possible continuation of execution, including the running of destructors, the object is considered inaccessible and the object becomes eligible for collection. Finally, at some time after the object becomes eligible for collection, the garbage collector frees the memory associated with that object. The process of selecting which objects are in use or not is detailed in the memory management life cycle of an object above. C# does not support automatic reference counting.
